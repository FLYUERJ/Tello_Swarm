#include <iostream>
#include <ViconDataStreamSDK_CPP/DataStreamClient.h>
#include <unistd.h>  // Para sleep()
#include <deque>     // Para std::deque

using namespace ViconDataStreamSDK::CPP;

const double TIME_INTERVAL = 0.1; // Intervalo de tempo entre as medições (em segundos)

int main()
{
    // Cria o cliente
    Client myClient;

    // Conecta ao servidor Vicon
    std::cout << "Connecting to Vicon server..." << std::endl;
    while (!myClient.IsConnected().Connected)
    {
        myClient.Connect("localhost:801");  // Substitua pelo endereço IP e porta do seu servidor Vicon
        std::cout << ".";
        sleep(1);
    }
    std::cout << "\nConnected!" << std::endl;

    // Configura o modo de transmissão
    myClient.SetStreamMode(StreamMode::ClientPull);

    // Configura o mapeamento de eixos
    myClient.SetAxisMapping(Direction::Forward, Direction::Left, Direction::Up);

    // Ativa os dados de segmentos
    myClient.EnableSegmentData();

    // Verifica se a ativação foi bem-sucedida
    if (!myClient.IsSegmentDataEnabled().Enabled)
    {
        std::cerr << "Failed to enable segment data!" << std::endl;
        return 1;
    }

    // Nome do sujeito e segmento para rastrear
    std::string subjectName = "Tello1";  // Nome do objeto que você está rastreando
    std::string segmentName = subjectName; // Para simplicidade, assumimos que o segmento principal tem o mesmo nome que o sujeito

    // Fila para armazenar as posições e tempos
    std::deque<std::pair<double[3], double>> positions; // <posição, tempo>

    while (true)
    {
        // Atualiza os dados
        myClient.GetFrame();

        // Obtém a tradução global do segmento
        Output_GetSegmentGlobalTranslation translation = myClient.GetSegmentGlobalTranslation(subjectName, segmentName);

        if (translation.Result == Result::Success)
        {
            double currentTime = static_cast<double>(time(nullptr)); // Obtém o tempo atual
            double position[3] = { translation.Translation[0], translation.Translation[1], translation.Translation[2] };

            // Adiciona a nova posição e tempo à fila
            positions.push_back(std::make_pair(position, currentTime));

            // Mantém apenas os dados mais recentes
            if (positions.size() > 3)
            {
                positions.pop_front();
            }

            if (positions.size() >= 2)
            {
                // Obtém as duas últimas posições e tempos
                auto [prevPosition, prevTime] = positions[positions.size() - 2];
                auto [currPosition, currTime] = positions.back();

                // Calcula a velocidade
                double deltaTime = currTime - prevTime;
                double velocity[3];
                for (int i = 0; i < 3; ++i)
                {
                    velocity[i] = (currPosition[i] - prevPosition[i]) / deltaTime;
                }

                // Calcula a aceleração, se houver dados suficientes
                if (positions.size() == 3)
                {
                    auto [prevPrevPosition, prevPrevTime] = positions[positions.size() - 3];
                    double prevDeltaTime = prevTime - prevPrevTime;
                    double prevVelocity[3];
                    for (int i = 0; i < 3; ++i)
                    {
                        prevVelocity[i] = (prevPosition[i] - prevPrevPosition[i]) / prevDeltaTime;
                    }

                    double acceleration[3];
                    for (int i = 0; i < 3; ++i)
                    {
                        acceleration[i] = (velocity[i] - prevVelocity[i]) / deltaTime;
                    }

                    // Exibe a aceleração
                    std::cout << "Acceleration: " << acceleration[0] << ", " << acceleration[1] << ", " << acceleration[2] << std::endl;
                }

                // Exibe a velocidade
                std::cout << "Velocity: " << velocity[0] << ", " << velocity[1] << ", " << velocity[2] << std::endl;
            }
            else
            {
                std::cout << "Not enough data to calculate velocity and acceleration." << std::endl;
            }
        }
        else
        {
            std::cerr << "Failed to get translation for " << subjectName << std::endl;
        }

        sleep(TIME_INTERVAL);  // Ajuste o intervalo conforme necessário
    }

    // Desconecta do servidor Vicon
    myClient.Disconnect();
    std::cout << "Disconnected from Vicon server." << std::endl;

    return 0;
}
