#include <iostream>
#include <ViconDataStreamSDK_CPP/DataStreamClient.h>
#include <unistd.h>  // Para sleep()
#include <deque>    // Para deque
#include <utility>  // Para std::pair
#include <chrono>   // Para std::chrono

using namespace ViconDataStreamSDK::CPP;

int main()
{
    // Cria o cliente
    Client myClient;

    // Conecta ao servidor Vicon
    std::cout << "Connecting to Vicon server..." << std::endl;
    while (!myClient.IsConnected().Connected)
    {
        myClient.Connect("localhost:801");  // Substitua pelo endereço IP e porta do seu servidor Vicon
        std::cout << ".";
        sleep(1);
    }
    std::cout << "\nConnected!" << std::endl;

    // Configura o modo de transmissão
    myClient.SetStreamMode(StreamMode::ClientPull);

    // Configura o mapeamento de eixos
    myClient.SetAxisMapping(Direction::Forward, Direction::Left, Direction::Up);

    // Ativa os dados de segmentos
    myClient.EnableSegmentData();

    // Verifica se a ativação foi bem-sucedida
    if (!myClient.IsSegmentDataEnabled().Enabled)
    {
        std::cerr << "Failed to enable segment data!" << std::endl;
        return 1;
    }

    // Nome do sujeito e segmento para rastrear
    std::string subjectName = "Disco";  // Nome do objeto que você está rastreando
    std::string segmentName = subjectName; // Para simplicidade, assumimos que o segmento principal tem o mesmo nome que o sujeito

    // Configura a fila para armazenar as últimas 3 posições e o tempo associado
    std::deque<std::pair<std::array<double, 3>, std::chrono::steady_clock::time_point>> positions;

    while (true)
    {
        // Atualiza os dados
        myClient.GetFrame();

        // Obtém a tradução global do segmento
        Output_GetSegmentGlobalTranslation translation = myClient.GetSegmentGlobalTranslation(subjectName, segmentName);

        if (translation.Result == Result::Success)
        {
            // Obtém a posição atual
            std::array<double, 3> position = { translation.Translation[0], translation.Translation[1], translation.Translation[2] };

            // Obtém o tempo atual
            auto currentTime = std::chrono::steady_clock::now();

            // Adiciona a nova posição e o tempo à fila
            positions.push_back(std::make_pair(position, currentTime));
            if (positions.size() > 3)
            {
                positions.pop_front();
            }

            // Verifica se há dados suficientes para calcular a velocidade e a aceleração
            if (positions.size() == 3)
            {
                // Calcula o intervalo de tempo entre as medições
                auto time1 = positions[0].second;
                auto time2 = positions[1].second;
                auto time3 = positions[2].second;
                double dt1 = std::chrono::duration<double>(time2 - time1).count();
                double dt2 = std::chrono::duration<double>(time3 - time2).count();

                if (dt1 > 0 && dt2 > 0)
                {
                    // Calcula as diferenças de posição
                    std::array<double, 3> pos1 = positions[0].first;
                    std::array<double, 3> pos2 = positions[1].first;
                    std::array<double, 3> pos3 = positions[2].first;

                    std::array<double, 3> velocity1 = {
                        (pos2[0] - pos1[0]) / dt1,
                        (pos2[1] - pos1[1]) / dt1,
                        (pos2[2] - pos1[2]) / dt1
                    };

                    std::array<double, 3> velocity2 = {
                        (pos3[0] - pos2[0]) / dt2,
                        (pos3[1] - pos2[1]) / dt2,
                        (pos3[2] - pos2[2]) / dt2
                    };

                    // Calcula a aceleração
                    std::array<double, 3> acceleration = {
                        (velocity2[0] - velocity1[0]) / ((dt1 + dt2) / 2.0),
                        (velocity2[1] - velocity1[1]) / ((dt1 + dt2) / 2.0),
                        (velocity2[2] - velocity1[2]) / ((dt1 + dt2) / 2.0)
                    };

                    // Exibe os resultados
                    std::cout << "Position: (" << position[0] << ", " << position[1] << ", " << position[2] << ")" << std::endl;
                    std::cout << "Velocity: (" << velocity2[0] << ", " << velocity2[1] << ", " << velocity2[2] << ")" << std::endl;
                    std::cout << "Acceleration: (" << acceleration[0] << ", " << acceleration[1] << ", " << acceleration[2] << ")" << std::endl;
                }
            }
        }
        else
        {
            std::cerr << "Failed to get translation for " << subjectName << std::endl;
        }

        sleep(1);  // Ajuste o intervalo conforme necessário
    }

    // Desconecta do servidor Vicon
    myClient.Disconnect();
    std::cout << "Disconnected from Vicon server." << std::endl;

    return 0;
}
